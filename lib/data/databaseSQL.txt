create extension if not exists "pgcrypto";

create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  email text not null unique,
  username text,
  avatar_url text,
  bio text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table if not exists public.alters (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  name text not null,
  pronoun text,
  color text not null default '#6A3AD3',
  description text,
  avatar_url text,
  is_active boolean not null default true,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  likes text,
  dislikes text,
  safety_instructions text
);

create table if not exists public.triggers (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  name text not null,
  description text,
  category text,
  intensity int default 3 check (intensity between 1 and 5),
  is_active boolean not null default true,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table if not exists public.front_sessions (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  alters text[] not null default '{}',
  triggers text[] default '{}',
  intensity int not null default 3 check (intensity between 1 and 5),
  notes text,
  is_cofront boolean not null default false,
  start_time timestamptz not null default now(),
  end_time timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table if not exists public.observers (
  id uuid primary key default gen_random_uuid(),
  owner_id uuid not null references public.profiles(id) on delete cascade,
  observer_id uuid not null references public.profiles(id) on delete cascade,
  can_view_alters boolean not null default true,
  can_view_sessions boolean not null default true,
  can_view_triggers boolean not null default false,
  can_edit boolean not null default false,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint observers_unique unique (owner_id, observer_id),
  constraint observers_different check (owner_id <> observer_id)
);

create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
begin
  insert into public.profiles (id, email, name)
  values (
    new.id,
    new.email,
    coalesce(new.raw_user_meta_data ->> 'name',
             split_part(new.email, '@', 1))
  );
  return new;
end;
$$;

drop trigger if exists on_auth_user_created on auth.users;

create trigger on_auth_user_created
after insert on auth.users
for each row
execute function public.handle_new_user();

create or replace function public.touch_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

create trigger touch_profiles
before update on public.profiles
for each row execute function public.touch_updated_at();

create trigger touch_alters
before update on public.alters
for each row execute function public.touch_updated_at();

create trigger touch_triggers
before update on public.triggers
for each row execute function public.touch_updated_at();

create trigger touch_sessions
before update on public.front_sessions
for each row execute function public.touch_updated_at();

create trigger touch_observers
before update on public.observers
for each row execute function public.touch_updated_at();

alter table public.profiles enable row level security;
alter table public.alters enable row level security;
alter table public.triggers enable row level security;
alter table public.front_sessions enable row level security;
alter table public.observers enable row level security;

-- Politicas
-- SELECT: usuário só vê o próprio perfil
drop policy if exists "profiles_select_own" on public.profiles;
create policy "profiles_select_own"
on public.profiles
for select
using (auth.uid() = id);

-- UPDATE: usuário só atualiza o próprio perfil
drop policy if exists "profiles_update_own" on public.profiles;
create policy "profiles_update_own"
on public.profiles
for update
using (auth.uid() = id);

-- INSERT: apenas o próprio usuário (usado pelo trigger)
drop policy if exists "profiles_insert_own" on public.profiles;
create policy "profiles_insert_own"
on public.profiles
for insert
with check (auth.uid() = id);

-- SELECT: dono ou observer com permissão
drop policy if exists "alters_select" on public.alters;
create policy "alters_select"
on public.alters
for select
using (
  user_id = auth.uid()
  OR exists (
    select 1
    from public.observers o
    where o.owner_id = alters.user_id
      and o.observer_id = auth.uid()
      and o.can_view_alters = true
  )
);

-- INSERT: somente dono
drop policy if exists "alters_insert_own" on public.alters;
create policy "alters_insert_own"
on public.alters
for insert
with check (auth.uid() = user_id);

-- UPDATE: somente dono
drop policy if exists "alters_update_own" on public.alters;
create policy "alters_update_own"
on public.alters
for update
using (auth.uid() = user_id);

-- DELETE: somente dono
drop policy if exists "alters_delete_own" on public.alters;
create policy "alters_delete_own"
on public.alters
for delete
using (auth.uid() = user_id);

-- SELECT: dono ou observer autorizado
drop policy if exists "triggers_select" on public.triggers;
create policy "triggers_select"
on public.triggers
for select
using (
  user_id = auth.uid()
  OR exists (
    select 1
    from public.observers o
    where o.owner_id = triggers.user_id
      and o.observer_id = auth.uid()
      and o.can_view_triggers = true
  )
);

-- INSERT: somente dono
drop policy if exists "triggers_insert_own" on public.triggers;
create policy "triggers_insert_own"
on public.triggers
for insert
with check (auth.uid() = user_id);

-- UPDATE: somente dono
drop policy if exists "triggers_update_own" on public.triggers;
create policy "triggers_update_own"
on public.triggers
for update
using (auth.uid() = user_id);

-- DELETE: somente dono
drop policy if exists "triggers_delete_own" on public.triggers;
create policy "triggers_delete_own"
on public.triggers
for delete
using (auth.uid() = user_id);

-- SELECT: dono ou observer autorizado
drop policy if exists "sessions_select" on public.front_sessions;
create policy "sessions_select"
on public.front_sessions
for select
using (
  user_id = auth.uid()
  OR exists (
    select 1
    from public.observers o
    where o.owner_id = front_sessions.user_id
      and o.observer_id = auth.uid()
      and o.can_view_sessions = true
  )
);

-- INSERT: somente dono
drop policy if exists "sessions_insert_own" on public.front_sessions;
create policy "sessions_insert_own"
on public.front_sessions
for insert
with check (auth.uid() = user_id);

-- UPDATE: somente dono
drop policy if exists "sessions_update_own" on public.front_sessions;
create policy "sessions_update_own"
on public.front_sessions
for update
using (auth.uid() = user_id);

-- DELETE: somente dono
drop policy if exists "sessions_delete_own" on public.front_sessions;
create policy "sessions_delete_own"
on public.front_sessions
for delete
using (auth.uid() = user_id);

-- SELECT: owner ou observer vê o relacionamento
drop policy if exists "observers_select_related" on public.observers;
create policy "observers_select_related"
on public.observers
for select
using (
  auth.uid() = owner_id
  OR auth.uid() = observer_id
);

-- INSERT: somente o dono cria observers
drop policy if exists "observers_insert_owner" on public.observers;
create policy "observers_insert_owner"
on public.observers
for insert
with check (auth.uid() = owner_id);

-- UPDATE: somente o dono altera permissões
drop policy if exists "observers_update_owner" on public.observers;
create policy "observers_update_owner"
on public.observers
for update
using (auth.uid() = owner_id);

-- DELETE: somente o dono remove observer
drop policy if exists "observers_delete_owner" on public.observers;
create policy "observers_delete_owner"
on public.observers
for delete
using (auth.uid() = owner_id);
